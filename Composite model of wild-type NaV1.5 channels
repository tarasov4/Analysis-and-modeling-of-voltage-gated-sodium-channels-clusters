class CnancyRudyAFM:

  def __init__(self, n_channels, interaction):
    self.n_channels = n_channels
    self.interaction = interaction
    self.s_init = np.zeros([4**self.n_channels, 1])
    self.s_init[0] = 1.
    self.make_composite_states()

  def make_composite_states(self):
    states = ['C', 'O', 'IF', 'IS']
    comp_states = [a+b for a in states for b in states]
    for k in range(self.n_channels-2):
      comp_states = [a+b for a in comp_states for b in states]
    self.comp_states = comp_states

  def make_init_Q(self, v):
    a11 = 3.802/(0.1027*np.exp(-v/17) + 0.2*np.exp(-v/150)) #rc3c2
    a12 = 3.802/(0.1027*np.exp(-v/15) + 0.23*np.exp(-v/150)) #rc2c1
    a13 = 2*3.802/(0.1027*np.exp(-v/12) + 0.25*np.exp(-v/150)) #rc1o #1.25* delta KPQ
    b11 = 0.1917*np.exp(-v/20.3) #rc2c3
    b12 = 0.2*np.exp(-(v-5)/20.3) #rc1c2
    b13 = 0.22*np.exp(-(v-10)/20.3)#roc1
    a2 = 9.178*np.exp(v/29.68) #roif
    a3 = 3.7933*10**-10 * np.exp(-v/5.2) #rifc1
    b3 = 0.0084 + 0.00002 * v #rc1if
    b2 = (a13 * a2 * a3)/(b13 * b3) #rifo
    a4 = a2/100
    b4 = a3
    Q = np.zeros((6, 6))
    Q[0, 1] = b11
    Q[1, 0], Q[1, 2] = a11, b12
    Q[2, 1], Q[2, 3], Q[2, 4] = a12, b13, a3
    Q[3, 2], Q[3, 4] = a13, b2
    Q[4, 2], Q[4, 3], Q[4, 5] = b3, a2, b4
    Q[5, 4] = a4
    matrix0 = tf.convert_to_tensor(Q)
    matrix0 = tf.gather(matrix0, [2,3,4,5], axis=1)
    matrix0 = tf.gather(matrix0, [2,3,4,5], axis=0)
    Q = matrix0.numpy()
    for i in range(Q.shape[0]):
      Q[i,i] = -Q[:,i].sum(0)
    #states: C, O, IF, IS
    assert np.all(np.isclose(Q.sum(0), np.zeros(Q.shape[0])))
    return Q

  def make_composite_Q(self, v):
    Q = self.make_init_Q(v)
    Q_comp = scipy.sparse.kronsum(Q, Q).todense()
    for k in range(self.n_channels-2):
      Q_comp = scipy.sparse.kronsum(Q_comp, Q).todense()
    assert np.all(np.isclose(Q_comp.sum(0), np.zeros(Q_comp.shape[0])))
    return Q_comp

  def make_interacting_Q(self, v, kT):
    states_to_scale_3_bonds = [self.n_channels*'C']
    states_to_scale_0_bonds = [_ for _ in self.comp_states if _ not in states_to_scale_3_bonds]
    indices_states_to_scale_3_bonds = [self.comp_states.index(com_state) for com_state in states_to_scale_3_bonds]
    indices_states_to_scale_0_bonds = [self.comp_states.index(com_state) for com_state in states_to_scale_0_bonds]
    Q_comp = self.make_composite_Q(v)
    Q_comp_int = Q_comp.copy()
    for ind in indices_states_to_scale_3_bonds:
      for ind_0 in indices_states_to_scale_0_bonds:     #barr lower  #energy of the state reduced
        Q_comp_int[ind_0:,ind] = Q_comp_int[ind_0:,ind]*np.exp(-kT)*np.exp(2*kT)
        Q_comp_int[ind:,ind_0] = Q_comp_int[ind:,ind_0]*np.exp(-kT) #energy barier is reduced
    for i in range(Q_comp_int.shape[0]):
      Q_comp_int[i,i] = -Q_comp_int[:i,i].sum(0)-Q_comp_int[i+1:,i].sum(0)
    return Q_comp_int

  def make_s(self, v_hold, kT, delta_t, duration):
    Q_hold = self.make_composite_Q(v_hold) if not self.interaction else self.make_interacting_Q(v_hold, kT)
    s = self.s_init
    A = scipy.linalg.expm(Q_hold*delta_t)
    for _ in range(int(duration/delta_t)):
      s = np.dot(A,s)
    return s

  def determ_P_t(self, v,  v_hold, kT, duration_at_v_hold, time):
    delta_t = np.round(time[1]-time[0], 2)
    Q = self.make_composite_Q(v) if not self.interaction else self.make_interacting_Q(v, kT)
    s = self.make_s(v_hold, kT, delta_t, duration_at_v_hold)
    T = time
    Q = tf.convert_to_tensor(Q, tf.float32)
    Q = Q[tf.newaxis, ...]
    time_points = T.shape[0]
    T = tf.convert_to_tensor(T, tf.float32)
    T =  T[..., tf.newaxis, tf.newaxis]
    Q_batch = tf.repeat(Q, repeats=time_points, axis=0)
    Qt_batch = Q_batch*T
    exp_Qt_batch = tf.linalg.expm(Qt_batch)
    s = tf.convert_to_tensor(s, tf.float32)
    P_t = tf.linalg.matmul(exp_Qt_batch, s).numpy().squeeze(-1).T
    return P_t

  def determ_sim_I(self, v,  v_hold, kT, duration_at_v_hold, time, i):

    P_t = self.determ_P_t(v,  v_hold, kT, duration_at_v_hold, time)
    I = np.zeros(P_t.shape[1])
    for n in range(1, self.n_channels+1):
      _idx = [state_idx for state_idx in range(len(self.comp_states)) if self.comp_states[state_idx].count('O')==n]
      I = I + n*i*P_t[_idx].sum(0)
    return I

  def determ_sim_recovery(self, v,  v_hold, v_hold_P1_P2, kT, duration_at_v_hold, time, i, test_intervals):

    P_t = self.determ_P_t(v,  v_hold, kT, duration_at_v_hold, time)
    I_P1 = np.zeros(P_t.shape[1])
    for n in range(1, self.n_channels+1):
      _idx = [state_idx for state_idx in range(len(self.comp_states)) if self.comp_states[state_idx].count('O')==n]
      I_P1 = I_P1 + n*i*P_t[_idx].sum(0)
    self.s_init = P_t[:,-1].reshape([-1,1])
    I_P2s = np.zeros([test_intervals.shape[0], time.shape[0]])
    for idx in range(test_intervals.shape[0]):
      I_P2s[idx] = self.determ_sim_I(v,  v_hold_P1_P2, kT, test_intervals[idx], time, i)

    return I_P1, I_P2s

n_channels = 2
v_test = -40
v_hold = -100
v_hold_P1_P2 = -100
kT = -.5
duration_at_v_hold = 100
i = -1.8
time = np.arange(0., 30, 0.01)
recovery_test_intervals = np.append(np.array([0.1]), np.arange(1, 50., 1.))

chnnel_pair_nonint,  chnnel_pair_int = CnancyRudyAFM(n_channels, False), CnancyRudyAFM(n_channels, True)
#I_nonint = chnnel_pair_nonint.determ_sim_I(v=v_test,  v_hold=v_hold, kT=kT, duration_at_v_hold=duration_at_v_hold, time=time, i=i)
#I_int = chnnel_pair_int.determ_sim_I(v=v_test,  v_hold=v_hold, kT=kT, duration_at_v_hold=duration_at_v_hold, time=time, i=i)
#plt.plot(time, I_nonint)
#plt.plot(time, I_int)

I_P1_nonint, I_P2s_nonint = chnnel_pair_nonint.determ_sim_recovery(v=v_test,  v_hold=v_hold, v_hold_P1_P2=v_hold_P1_P2, kT=kT, duration_at_v_hold=duration_at_v_hold, time=time, i=i, test_intervals=recovery_test_intervals)
I_P1_int, I_P2s_int = chnnel_pair_int.determ_sim_recovery(v=v_test,  v_hold=v_hold, v_hold_P1_P2=v_hold_P1_P2, kT=kT, duration_at_v_hold=duration_at_v_hold, time=time, i=i, test_intervals=recovery_test_intervals)
plt.scatter(recovery_test_intervals, I_P2s_nonint.min(1)/I_P1_nonint.min())
plt.scatter(recovery_test_intervals, I_P2s_int.min(1)/I_P1_int.min())
